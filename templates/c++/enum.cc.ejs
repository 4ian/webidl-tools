using v8::Local;
using v8::String;
using v8::Value;

using <%- namespace %>::<%- enumName(node) %>;

static std::string <%- enumName(node) %>ToString(<%- enumName(node) %> parsed) {
  switch (parsed) {
<%_ node.values.forEach(value => { _%>
    case <%- toEnum(node.name, value) %>:
      return <%- toStringLiteral(value) %>;
<%_ }) _%>
  }
}

Local<Value> <%- enumName(node) %>ToV8(<%- enumName(node) %> parsed) {
  Nan::EscapableHandleScope scope;
  return scope.Escape(Nan::New<String>(<%- enumName(node) %>ToString(parsed)).ToLocalChecked());
}

static Nan::Maybe<<%- enumName(node) %>> <%- enumName(node) %>FromString(std::string unparsed, std::string *error) {
<%_ node.values.forEach((value, i) => { _%>
  <%- i > 0 ? '} else ' : '' %>if (unparsed.compare(<%- toStringLiteral(value) %>) == 0) {
    return Nan::Just<<%- enumName(node) %>>(<%- toEnum(node.name, value) %>);
<%_ }) _%>
  }
  if (error != nullptr) {
    *error = "The provided value '" + unparsed + "' is not a valid enum value of type <%- enumName(node) %>.";
  }
  return Nan::Nothing<<%- enumName(node) %>>();
}

Nan::Maybe<<%- enumName(node) %>> <%- enumName(node) %>FromV8(Local<Value> unparsed, std::string *error) {
  return <%- enumName(node) %>FromString(std::string(*String::Utf8Value(unparsed->ToString())), error);
}

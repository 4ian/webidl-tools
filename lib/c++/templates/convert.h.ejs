#ifndef <%- headerDefine('convert') %>
#define <%- headerDefine('convert') %>

#include "nan.h"
#include "v8.h"

#include "webrtc/base/optional.h"

#include "<%- this.path ? this.path + '/' : '' %>either.h"

namespace <%- namespace %> {

// Convert defines a partial isomorphism between types F and T: for any value
// of type T, you can construct a value of type F with To; for any value of
// type F, you might be able to construct a value of type T. The potential for
// failure is modeled by Either: either the function returns a value of type
// T (Right), or it returns an error string (Left).
template <typename T, typename F>
struct Convert;

// rtc::Optional<T>

template <typename T>
struct Convert<rtc::Optional<T>, v8::Local<v8::Value>> {
  static Either<std::string, rtc::Optional<T>> From(v8::Local<v8::Value> value) {
    Nan::HandleScope scope;

    if (value->IsUndefined() || value->IsNull()) {
      return Either<std::string, rtc::Optional<T>>::Right(rtc::Optional<T>());
    }

    Either<std::string, T> maybeValue = Convert<T, v8::Local<v8::Value>>::From(value);
    if (!maybeValue) {
      return Either<std::string, rtc::Optional<T>>::Left(maybeValue.left());
    }

    return Either<std::string, rtc::Optional<T>>::Right(rtc::Optional<T>(*maybeValue));
  }

  static v8::Local<v8::Value> To(rtc::Optional<T> value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(value
      ? Convert<T, v8::Local<v8::Value>>::To(*value)
      : static_cast<v8::Local<v8::Value>>(Nan::Null()));
  }
};

// Either<L, R>

template <typename L, typename R, typename F>
struct Convert<Either<L, R>, F> {
  static Either<std::string, Either<L, R>> From(F value) {
    Nan::HandleScope scope;
    Either<std::string, L> maybeLeft = Convert<L, F>::From(value);
    if (!maybeLeft) {
      Either<std::string, R> maybeRight = Convert<R, F>::From(value);
      if (!maybeRight) {
        return Either<std::string, Either<L, R>>::Left(maybeRight.left());
      }
      return Either<std::string, Either<L, R>>::Right(Either<L, R>::Right(maybeRight.right()));
    }
    return Either<std::string, Either<L, R>>::Right(Either<L, R>::Left(maybeLeft.right()));
  }

  static F ToV8(Either<L, R> value) {
    Nan::EscapableHandleScope scope;
    if (value.IsLeft()) {
      return scope.Escape(Convert<L, F>::To(value.left()));
    }
    return scope.Escape(Convert<R, F>::To(value.right()));
  }
};

// std::vector<T>

template <typename T>
struct Convert<std::vector<T>, v8::Local<v8::Value>> {
  static Either<std::string, std::vector<T>> From(v8::Local<v8::Value> value) {
    Nan::HandleScope scope;

    v8::Local<v8::Array> array = value.As<v8::Array>();
    if (array.IsEmpty()) {
      return Either<std::string, std::vector<T>>::Left("Expected an Array");
    }

    uint32_t length = array->Length();
    std::vector<T> results;

    for (uint32_t i = 0; i < length; i++) {
      v8::Local<v8::Value> element = Nan::Get(array, i).FromMaybe(static_cast<v8::Local<v8::Value>>(Nan::Undefined()));
      Either<std::string, T> value = Convert<T, v8::Local<v8::Value>>::From(element);
      if (!value) {
        return Either<std::string, std::vector<T>>::Left(value.left());
      }
      results.push_back(*value);
    }

    return Either<std::string, std::vector<T>>::Right(results);
  }

  static v8::Local<v8::Value> To(std::vector<T> value) {
    Nan::EscapableHandleScope scope;
    v8::Local<v8::Array> array = Nan::New<v8::Array>();
    for (size_t i = 0; i < value.size(); i++) {
      Nan::Set(array, 0, Convert<T, v8::Local<v8::Value>>::To(value[i]));
    }
    return array;
  }
};

// bool

template<>
struct Convert<bool, v8::Local<v8::Value>> {
  static Either<std::string, bool> From(v8::Local<v8::Value> value) {
    Nan::HandleScope scope;
    return value.IsEmpty()
      ? Either<std::string, bool>::Right(false)
      : Either<std::string, bool>::Right(value->BooleanValue());
  }

  static v8::Local<v8::Value> To(bool value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New<v8::Boolean>(value));
  }
};

// std::string

template<>
struct Convert<std::string, v8::Local<v8::Value>> {
  static Either<std::string, std::string> From(v8::Local<v8::Value> value) {
    Nan::HandleScope scope;
    return Either<std::string, std::string>::Right(std::string(*v8::String::Utf8Value(value->ToString())));
  }

  static v8::Local<v8::Value> To(std::string value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New(value).ToLocalChecked());
  }
};

// unsigned short

template <>
struct Convert<unsigned short, v8::Local<v8::Value>> {
  static Either<std::string, unsigned short> From(v8::Local<v8::Value> value) {
    if (!value->IsNumber()) {
      return Either<std::string, unsigned short>::Left("Expected a number");
    }
    return Either<std::string, unsigned short>::Right(static_cast<unsigned short>(value->Uint32Value()));
  }

  static v8::Local<v8::Value> To(unsigned short value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New<v8::Integer>(value));
  }
};

}  // <%- namespace %>

#endif  // <%- headerDefine('convert') %>

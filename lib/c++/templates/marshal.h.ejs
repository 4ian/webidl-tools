#ifndef <%- headerDefine('marshal') %>
#define <%- headerDefine('marshal') %>

#include "nan.h"
#include "v8.h"

#include "webrtc/base/optional.h"

namespace <%- namespace %> {

template <typename T>
struct Marshal;

// rtc::Optional<T>
// ----------------

template <typename T>
struct Marshal<rtc::Optional<T>> {
  static rtc::Optional<rtc::Optional<T>> FromV8(v8::Local<v8::Value> value, std::string *error) {
    Nan::HandleScope scope;

    if (value->IsUndefined() || value->IsNull()) {
      return rtc::Optional<rtc::Optional<T>>(rtc::Optional<T>());
    }

    rtc::Optional<T> maybeValue = Marshal<T>::FromV8(value, error);
    if (!maybeValue) {
      return rtc::Optional<rtc::Optional<T>>();
    }

    return rtc::Optional<rtc::Optional<T>>(maybeValue);
  }

  static v8::Local<v8::Value> ToV8(rtc::Optional<T> value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(value
      ? Marshal<T>::ToV8(*value)
      : static_cast<v8::Local<v8::Value>>(Nan::Null()));
  }
};

// std::vector<T>
// --------------

template <typename T>
struct Marshal<std::vector<T>> {
  static rtc::Optional<std::vector<T>> FromV8(v8::Local<v8::Value> value, std::string *error) {
    Nan::HandleScope scope;

    v8::Local<v8::Array> array = value.As<v8::Array>();
    if (array.IsEmpty()) {
      if (error != nullptr) {
        *error = "Expected an Array";
      }
      return rtc::Optional<std::vector<T>>();
    }

    uint32_t length = array->Length();
    std::vector<T> results;

    for (uint32_t i = 0; i < length; i++) {
      v8::Local<v8::Value> element = Nan::Get(array, i).FromMaybe(static_cast<v8::Local<v8::Value>>(Nan::Undefined()));
      rtc::Optional<T> value = Marshal<T>::FromV8(element, error);
      if (!value) {
        return rtc::Optional<std::vector<T>>(); 
      }
      results.push_back(*value);
    }

    return rtc::Optional<std::vector<T>>(results);
  }

  static v8::Local<v8::Value> ToV8(std::vector<T> value) {
    Nan::EscapableHandleScope scope;
    v8::Local<v8::Array> array = Nan::New<v8::Array>();
    for (size_t i = 0; i < value.size(); i++) {
      Nan::Set(array, 0, Marshal<T>::ToV8(value[i]));
    }
    return array;
  }
};

// bool
// ----

template<>
struct Marshal<bool> {
  static rtc::Optional<bool> FromV8(v8::Local<v8::Value> value, std::string *error) {
    Nan::HandleScope scope;
    return value.IsEmpty()
      ? rtc::Optional<bool>(false)
      : rtc::Optional<bool>(value->BooleanValue());
  }

  static v8::Local<v8::Value> ToV8(bool value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New<v8::Boolean>(value));
  }
};

// std::string
// -----------

template<>
struct Marshal<std::string> {
  static rtc::Optional<std::string> FromV8(v8::Local<v8::Value> value, std::string *error) {
    Nan::HandleScope scope;
    return rtc::Optional<std::string>(std::string(*v8::String::Utf8Value(value->ToString())));
  }

  static v8::Local<v8::Value> ToV8(std::string value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New(value).ToLocalChecked());
  }
};

// unsigned short
// --------------

template <>
struct Marshal<unsigned short> {
  static rtc::Optional<unsigned short> FromV8(v8::Local<v8::Value> value, std::string *error) {
    if (!value->IsNumber()) {
      if (error != nullptr) {
        *error = "Expected a number";
      }
      return rtc::Optional<unsigned short>();
    }
    return rtc::Optional<unsigned short>(static_cast<unsigned short>(value->Uint32Value()));
  }

  static v8::Local<v8::Value> ToV8(unsigned short value) {
    Nan::EscapableHandleScope scope;
    return scope.Escape(Nan::New<v8::Integer>(value));
  }
};

}  // <%- namespace %>

#endif  // <%- headerDefine('marshal') %>

using v8::Local;
using v8::String;
using v8::Value;

using <%- namespace %>::Marshal;
using <%- namespace %>::<%- enumName(node) %>;

static rtc::Optional<<%- enumName(node) %>> <%- enumName(node) %>FromString(std::string value, std::string *error) {
<%_ node.values.forEach((value, i) => { _%>
  <%- i > 0 ? '} else ' : '' %>if (value.compare(<%- toStringLiteral(value) %>) == 0) {
    return rtc::Optional<<%- enumName(node) %>>(<%- toEnum(node.name, value) %>);
<%_ }) _%>
  }
  if (error != nullptr) {
    *error = "The provided value '" + value + "' is not a valid enum value of type <%- enumName(node) %>.";
  }
  return rtc::Optional<<%- enumName(node) %>>();
}

rtc::Optional<<%- enumName(node) %>> Marshal<<%- enumName(node) %>>::FromV8(Local<Value> value, std::string *error) {
  Nan::HandleScope scope;
  return <%- enumName(node) %>FromString(std::string(*String::Utf8Value(value->ToString())), error);
}

static std::string <%- enumName(node) %>ToString(<%- enumName(node) %> value) {
  switch (value) {
<%_ node.values.forEach(value => { _%>
    case <%- toEnum(node.name, value) %>:
      return <%- toStringLiteral(value) %>;
<%_ }) _%>
  }
}

Local<Value> Marshal<<%- enumName(node) %>>::ToV8(<%- enumName(node) %> value) {
  Nan::EscapableHandleScope scope;
  return scope.Escape(Nan::New<String>(<%- enumName(node) %>ToString(value)).ToLocalChecked());
}

using v8::Local;
using v8::String;
using v8::Value;

<%- usings(node) %>

Either<std::string, <%- enumName(node) %>> Convert<<%- enumName(node) %>, std::string>::From(std::string value) {
<%_ node.values.forEach((value, i) => { _%>
  <%- i > 0 ? '} else ' : '' %>if (value.compare(<%- toStringLiteral(value) %>) == 0) {
    return Either<std::string, <%- enumName(node) %>>::Right(<%- toEnum(node.name, value) %>);
<%_ }) _%>
  }
  return Either<std::string, <%- enumName(node) %>>::Left("The provided value '" + value + "' is not a valid enum value of type <%- enumName(node) %>.");
}

std::string Convert<<%- enumName(node) %>, std::string>::To(<%- enumName(node) %> value) {
  switch (value) {
<%_ node.values.forEach(value => { _%>
    case <%- toEnum(node.name, value) %>:
      return <%- toStringLiteral(value) %>;
<%_ }) _%>
  }
}

Either<std::string, <%- enumName(node) %>> Convert<<%- enumName(node) %>, v8::Local<v8::Value>>::From(Local<Value> value) {
  Nan::HandleScope scope;
  return Convert<<%- enumName(node) %>, std::string>::From(std::string(*String::Utf8Value(value->ToString())));
}

Local<Value> Convert<<%- enumName(node) %>, v8::Local<v8::Value>>::To(<%- enumName(node) %> value) {
  Nan::EscapableHandleScope scope;
  return scope.Escape(Nan::New<String>(Convert<<%- enumName(node) %>, std::string>::To(value)).ToLocalChecked());
}

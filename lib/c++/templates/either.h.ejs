#ifndef <%- headerDefine('either') %>
#define <%- headerDefine('either') %>

#include "nan.h"
#include "v8.h"

#include "webrtc/base/optional.h"

#include "<%- path ? path + '/' : '' %>marshal.h"

namespace <%- namespace %> {

template <typename L, typename R>
class Either  {
 public:
  Either<L, R>() {}

  static Either<L, R> Left(L left) {
    return Either(rtc::Optional<L>(left), rtc::Optional<R>());
  }

  static Either<L, R> Right(R right) {
    return Either(rtc::Optional<L>(), rtc::Optional<R>(right));
  }

  bool IsLeft() { return bool(_left); };
  bool IsRight() { return bool(_right); };

  L left() { return *_left; };
  L left_or(L default_val) { return _left.value_or(default_val); };

  R right() { return *_right; };
  R right_or(R default_val) { return _right.value_or(default_val); };

 private:
  Either(
    rtc::Optional<L> left,
    rtc::Optional<R> right):
      _left(left),
      _right(right) {}

  rtc::Optional<L> _left;
  rtc::Optional<R> _right;
};

template <typename L, typename R>
struct Marshal<Either<L, R>> {
  static rtc::Optional<Either<L, R>> FromV8(v8::Local<v8::Value> value, std::string *error) {
    Nan::HandleScope scope;
    std::string leftError;
    rtc::Optional<L> maybeLeft = Marshal<L>::FromV8(value, &leftError);
    if (!maybeLeft) {
      std::string rightError;
      rtc::Optional<R> maybeRight = Marshal<R>::FromV8(value, &rightError);
      if (!maybeRight) {
        if (error != nullptr) {
          *error = rightError;
        }
        return rtc::Optional<Either<L, R>>();
      }
      return rtc::Optional<Either<L, R>>(Either<L, R>::Right(*maybeRight));
    }
    return rtc::Optional<Either<L, R>>(Either<L, R>::Left(*maybeLeft));
  }

  static v8::Local<v8::Value> ToV8(Either<L, R> value) {
    Nan::EscapableHandleScope scope;
    if (value.IsLeft()) {
      return scope.Escape(Marshal<L>::ToV8(value.left()));
    }
    return scope.Escape(Marshal<R>::ToV8(value.right()));
  }
};

}  // <%- namespace %>

#endif  // <%- headerDefine('either') %>

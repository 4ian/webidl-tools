#ifndef <%- headerDefine('either') %>
#define <%- headerDefine('either') %>

#include <algorithm>
#include <utility>

#include "<%- path ? path + '/' : '' %>optional.h"

namespace <%- namespace %> {

// An Either<L, R> contains either a value of type L (constructed with Left), or
// a value of type R (constructed with Right). This class is modeled directly
// after Haskell's Either data type and is, in some sense, "right-biased", i.e.
//
// - the default constructor returns a "right".
// - conversion to bool is the same as IsRight().
// - dereference is the same as right().
//
template <typename L, typename R>
class Either final {
 public:
  // WARN(mroberts): Do not call this constructor. It breaks the invariant that
  // either a left or right value is present. This constructor is only included
  // so that Convert can return Optionals of Eithers.
  Either() {}

  // Construct an Either that contains a right value.
  explicit Either(R right): Either(Optional<L>(), Optional<R>(right)) {}

  // Construct an Either that contains a left value.
  static Either Left(L left) { return Either(Optional<L>(left), Optional<R>()); }

  // Construct an Either that contains a right value.
  static Either Right(R right) { return Either(Optional<L>(), Optional<R>(right)); }

  // Copy and move constructors.
  Either(const Either&) = default;
  Either(Either&& e): left_(std::move(e.left_)), right_(std::move(e.right_)) {}

  // Assignment.
  Either& operator=(const Either&) = default;
  Either& operator=(Either&& e) {
    left_ = std::move(e.left_);
    right_ = std::move(e.right_);
    return *this;
  }

  friend void swap(Either& e1, Either& e2) {
    using std::swap;
    swap(e1.left_, e2.left_);
    swap(e1.right_, e2.right_);
  }

  // Flip an Either.
  const Either<R, L> flip() const { return Either<R, L>(right_, left_); }
  Either<R, L> flip() { return Either<R, L>(right_, left_); }

  // Test if the Either contains a left value.
  bool IsLeft() const { return bool(left_); }

  // Test if the Either contains a right value.
  bool IsRight() const { return bool(right_); }

  // Conversion to bool to test if we have a right value.
  explicit operator bool() { return IsRight(); }

  // Dereference the left value. Only allowed if we have a left value.
  const L& left() const { return *left_; }
  L& left() { return *left_; }

  // Dereference the left value with a default value in case we don't have a left value.
  const L& left_or(const L& default_val) const { return left_.value_or(default_val); }

  // Dereference the right value. Only allowed if we have a right value.
  const R& right() const { return *right_; }
  R& right() { return *right_; }

  // Dereference the right value with a default value in case we don't have a right value.
  const R& right_or(const R& default_val) const { return right_.value_or(default_val); }

  // Dereferencing. Only allowed if we have a right value.
  const R* operator->() const { return &(right()); }
  R* operator->() { return &(right()); }
  const R& operator*() const { return right(); }
  R& operator*() { return right(); }

  // Equality tests. Two Eithers are equal if they both contain left values or
  // both contain right values and if those values are equivalent.
  friend bool operator==(const Either& e1, const Either& e2) {
    return (e1.IsLeft()  && e2.IsLeft()  && e1.left() == e2.left())
        || (e1.IsRight() && e2.IsRight() && *e1       == *e2);
  }
  friend bool operator!=(const Either& e1, const Either& e2) {
    return (e1.IsLeft()  && e2.IsLeft()  && e1.left() != e2.left())
        || (e1.IsRight() && e2.IsRight() && *e1       != *e2)
        || true;
  }

 private:
  // Invariant: Either a left or a right value must be provided, but not both.
  Either(
    Optional<L> left,
    Optional<R> right):
      left_(left),
      right_(right) {}

  Optional<L> left_;
  Optional<R> right_;
};

}  // <%- namespace %>

#endif  // <%- headerDefine('either') %>

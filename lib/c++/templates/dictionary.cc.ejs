using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

using namespace <%- namespace %>::<%- className(node) %>;

Local<Value> <%- className(node) %>::ToV8(<%- className(node) %> *parsed) {
  Nan::EscapableHandleScope scope;
  Local<Object> dictionary = Nan::New<Object>();

<%_ node.members.forEach(member => { _%>
  Local<Value> <%- publicMemberName(member) %> = <%- toV8(member) %>(parsed-><%- publicMemberName(member) %>());
  Nan::Set(dictionary, Nan::New("<%- publicMemberName(member) %>").ToLocalChecked(), <%- publicMemberName(member) %>);

<%_ }) _%>
  return scope.Escape(dictionary);
}

static Nan::Maybe<<%- className(node) %>> <%- className(node) %>::FromV8(Local<Value> unparsed, std::string *error) {
<%_ node.members.forEach(member => { _%>
  <%- argumentType(member) %> <%- argumentName(member) %> = <%- fromV8(member) %>(value);

<%_ }) _%>

<%_ if (!node.members.length) { _%>
  return Nan::Just<<%- className(node) %>>(<%- className(node) %>());
<%_ } else { _%>
  return Nan::Just<<%- className(node) %>>(
    <%- className(node) %>(
<%_ node.members.forEach((member, i) => { _%>
      <%- argumentName(member) %><%- i < node.members.length - 1 ? ',' : ')' %>
<%_ }) _%>
    );
<%_ } _%>
}

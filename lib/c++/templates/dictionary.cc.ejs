using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

<%- usings(node) %>

Local<Value> <%- className(node) %>::ToV8() {
  Nan::EscapableHandleScope scope;
  Local<Object> dictionary = Nan::New<Object>();

<%_ node.members.forEach(member => { _%>
  Local<Value> <%- publicMemberName(member) %> = Marshal<<%- publicMemberType(member) %>>::ToV8(this-><%- publicMemberName(member) %>());
  Nan::Set(dictionary, Nan::New("<%- publicMemberName(member) %>").ToLocalChecked(), <%- publicMemberName(member) %>);

<%_ }) _%>
  return scope.Escape(dictionary);
}

rtc::Optional<<%- className(node) %>> <%- className(node) %>::FromV8(Local<Value> value, std::string *error) {
  Nan::HandleScope scope;

  Local<Object> dictionary = value.As<Object>();
  if (dictionary.IsEmpty()) {
    if (error != nullptr) {
      *error = "Expected an object";
    }
    return rtc::Optional<<%- className(node) %>>();
  }

  Nan::MaybeLocal<Value> maybeValue;

<%_ node.members.forEach(member => { _%>
  maybeValue = Nan::Get(dictionary, Nan::New("<%- publicMemberName(member) %>").ToLocalChecked());
  if (maybeValue.IsEmpty()) {
    if (error != nullptr) {
      *error = "Unable to access property <%- publicMemberName(member) %>";
    }
    return rtc::Optional<<%- className(node) %>>();
  }
  rtc::Optional<<%- argumentType(member) %>> <%- argumentName(member) %> = Marshal<<%- argumentType(member) %>>::FromV8(maybeValue.ToLocalChecked(), error);
  if (!<%- argumentName(member) %>) {
    return rtc::Optional<<%- className(node) %>>();
  }

<%_ }) _%>
<%_ if (!node.members.length) { _%>
  return rtc::Optional<<%- className(node) %>>(<%- className(node) %>());
<%_ } else { _%>
  return rtc::Optional<<%- className(node) %>>(<%- className(node) %>(
<%_ node.members.forEach((member, i) => { _%>
    *<%- argumentName(member) %><%- i < node.members.length - 1 ? ',' : '));' %>
<%_ }) _%>
<%_ } _%>
}

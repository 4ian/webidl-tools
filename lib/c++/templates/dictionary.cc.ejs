using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

<%- usings(node) %>

Local<Value> <%- className(node) %>::ToV8() {
  Nan::EscapableHandleScope scope;
  Local<Object> dictionary = Nan::New<Object>();

<%_ node.members.forEach(member => { _%>
  Local<Value> <%- publicMemberName(member) %> = Convert<<%- publicMemberType(member) %>, Local<Value>>::To(this-><%- publicMemberName(member) %>());
  Nan::Set(dictionary, Nan::New("<%- publicMemberName(member) %>").ToLocalChecked(), <%- publicMemberName(member) %>);

<%_ }) _%>
  return scope.Escape(dictionary);
}

Either<std::string, <%- className(node) %>> <%- className(node) %>::FromV8(Local<Value> value) {
  Nan::HandleScope scope;

  Local<Object> dictionary = value.As<Object>();
  if (dictionary.IsEmpty()) {
    return Either<std::string, <%- className(node) %>>::Left("Expected an object");
  }

  Nan::MaybeLocal<Value> maybeValue;

<%_ node.members.forEach(member => { _%>
  maybeValue = Nan::Get(dictionary, Nan::New("<%- publicMemberName(member) %>").ToLocalChecked());
  if (maybeValue.IsEmpty()) {
    return Either<std::string, <%- className(node) %>>::Left("Unable to access property <%- publicMemberName(member) %>");
  }
  Either<std::string, <%- argumentType(member) %>> <%- argumentName(member) %> = Convert<<%- argumentType(member) %>, Local<Value>>::From(maybeValue.ToLocalChecked());
  if (!<%- argumentName(member) %>) {
    return Either<std::string, <%- className(node) %>>::Left(<%- argumentName(member) %>.left());
  }

<%_ }) _%>
<%_ if (!node.members.length) { _%>
  return Either<std::string, <%- className(node) %>>::Right(<%- className(node) %>());
<%_ } else { _%>
  return Either<std::string, <%- className(node) %>>::Right(<%- className(node) %>(
<%_ node.members.forEach((member, i) => { _%>
    *<%- argumentName(member) %><%- i < node.members.length - 1 ? ',' : '));' %>
<%_ }) _%>
<%_ } _%>
}
